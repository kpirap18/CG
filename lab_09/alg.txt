

def scalar_mult(a, b):
    return a[0] * b[0] + a[1] * b[1]


def vector_mult(a, b):
    return a[0] * b[1] - a[1] * b[0] 
    # Ax * By - Ay * Bx --- это будет координата Z, которая нам нужна


def is_convex(arr):
    if len(arr) < 3:
        return False

    a = [arr[0][0] - arr[-1][0], arr[0][1] - arr[-1][1]]
    b = [arr[-1][0] - arr[-2][0], arr[-1][1] - arr[-2][1]]
    prev = sign(vector_mult(a, b))
    for i in range(1, len(arr) - 2):
        a = [arr[i][0] - arr[i - 1][0], arr[i][1] - arr[i - 1][1]]
        b = [arr[i - 1][0] - arr[i - 2][0], arr[i - 1][1] - arr[i - 2][1]]
        cur = sign(vector_mult(a, b))
        if prev != cur:
            return False
        prev = cur

    if (check_cross(arr)):
        return False

    return True


def get_normal(a, b, pos):
    fvec = [b[0] - a[0], b[1] - a[1]]
    posvec = [pos[0] - b[0], pos[1] - b[1]]

    if fvec[1]:
        fpoint = -fvec[0] / fvec[1]
        normvec = [1, fpoint]
    else:
        normvec = [0, 1]

    if scalar_mult(posvec, normvec) < 0:
        normvec[0] = -normvec[0]
        normvec[1] = -normvec[1]

    return normvec


def is_visible(point, f, s):
    v1 = [s[0] - f[0], s[1] - f[1]]
    v2 = [point[0] - f[0], point[1] - f[1]]
    if vector_mult(v1, v2) < 0:
        return False
    else:
        return True


def cross_two_segment(seg, side, normal):
    d = [seg[1][0] - seg[0][0], seg[1][1] - seg[0][1]]
    w = [seg[0][0] - side[0][0], seg[0][1] - side[0][1]]

    d_scal = scalar_mult(d, normal)
    w_scal = scalar_mult(w, normal)

    param = -w_scal / d_scal

    return [seg[0][0] +d[0] * param, seg[0][1] + d[1] * param]


def cut_side(res, side, pos):
    print("cut_side")
    ret = []

    normal = get_normal(side[0], side[1], pos)

    prev_vis = is_visible(res[-2], side[0], side[1])
    print(prev_vis)

    for cur_point in range(-1, len(res)):
        print(cur_point)
        cur_vis = is_visible(res[cur_point], side[0], side[1])
        print(cur_vis)
        if prev_vis:
            if cur_vis:
                ret.append(res[cur_point])
            else:
                ret.append(cross_two_segment([res[cur_point - 1], res[cur_point]], side, normal))
        else:
            if cur_vis:
                ret.append(cross_two_segment([res[cur_point - 1], res[cur_point]], side, normal))
                ret.append(res[cur_point])    

        prev_vis = cur_vis

    print(ret)
    return ret


def Sutherland_Hodgman():    
    figure = wind.lines
    cutter = wind.rect

    print(figure, cutter, len(cutter))

    if not is_convex(cutter):
        QMessageBox.warning(wind, "Внимание!", "Отсекатель невыпусклый!!!")
        return 

    result = figure
    for cur_point in range(-1, len(cutter) - 1):
        print(cur_point)
        result = cut_side(result, [cutter[cur_point], cutter[cur_point + 1]],
                          cutter[cur_point + 1])
        if len(result) <= 2:
            return []
    
    print("!!!!!!@@@@@@@@@@@@@@@@@@@@", result)

    draw_lines(result)
    return
